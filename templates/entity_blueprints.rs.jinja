// GENERATED CODE â€” DO NOT EDIT
// Generated via Copier from cold path YAML entity blueprint schemas
use hecs::World;
use crate::gen::components::*;

{% for blueprint in entity_blueprints -%}
/// {{ blueprint.name }} v{{ blueprint.version }} - {{ blueprint.description }}
pub struct {{ blueprint.name }}Blueprint;

impl {{ blueprint.name }}Blueprint {
    pub const VERSION: u32 = {{ blueprint.version }};
    pub const NAME: &'static str = "{{ blueprint.name }}";
    pub const DESCRIPTION: &'static str = "{{ blueprint.description }}";
    pub const SPAWN_PROBABILITY: f32 = {{ blueprint.spawn_probability }};
    
    /// Spawn a {{ blueprint.name }} entity with default component values
    pub fn spawn(world: &mut World) -> hecs::Entity {
        world.spawn((
            {%- for component in blueprint.components %}
            {%- if component.default_values %}
            {{ component.type }} {
                {%- for field_name, field_value in component.default_values %}
                {{ field_name }}: {{ field_value | rust_default }},
                {%- endfor %}
            },
            {%- else %}
            {{ component.type }}::default(),
            {%- endif %}
            {%- endfor %}
        ))
    }
    
    /// Spawn a {{ blueprint.name }} entity with custom component values
    pub fn spawn_with_overrides(
        world: &mut World,
        overrides: std::collections::HashMap<&str, serde_json::Value>
    ) -> hecs::Entity {
        // For now, use default spawning - custom overrides can be added later
        Self::spawn(world)
    }
    
    /// Get component types for this blueprint
    pub fn component_types() -> &'static [&'static str] {
        &[
            {%- for component in blueprint.components %}
            "{{ component.type }}",
            {%- endfor %}
        ]
    }
    
    /// Check if this blueprint should spawn based on probability
    pub fn should_spawn() -> bool {
        use rand::Rng;
        let mut rng = rand::thread_rng();
        rng.gen::<f32>() < Self::SPAWN_PROBABILITY
    }
}

{% endfor -%}

/// Entity blueprint registry for runtime introspection
pub struct EntityBlueprintRegistry;

impl EntityBlueprintRegistry {
    pub fn get_all_blueprints() -> Vec<(String, u32)> {
        vec![
            {%- for blueprint in entity_blueprints %}
            ("{{ blueprint.name }}".to_string(), {{ blueprint.version }}),
            {%- endfor %}
        ]
    }
    
    pub fn spawn_by_name(world: &mut World, blueprint_name: &str) -> Option<hecs::Entity> {
        match blueprint_name {
            {%- for blueprint in entity_blueprints %}
            "{{ blueprint.name }}" => Some({{ blueprint.name }}Blueprint::spawn(world)),
            {%- endfor %}
            _ => None,
        }
    }
    
    pub fn get_component_types(blueprint_name: &str) -> Option<&'static [&'static str]> {
        match blueprint_name {
            {%- for blueprint in entity_blueprints %}
            "{{ blueprint.name }}" => Some({{ blueprint.name }}Blueprint::component_types()),
            {%- endfor %}
            _ => None,
        }
    }
    
    pub fn get_spawn_probability(blueprint_name: &str) -> Option<f32> {
        match blueprint_name {
            {%- for blueprint in entity_blueprints %}
            "{{ blueprint.name }}" => Some({{ blueprint.name }}Blueprint::SPAWN_PROBABILITY),
            {%- endfor %}
            _ => None,
        }
    }
}

/// Batch entity spawning utilities
pub struct EntitySpawner;

impl EntitySpawner {
    /// Spawn a random entity based on probabilities
    pub fn spawn_random(world: &mut World) -> Option<hecs::Entity> {
        use rand::Rng;
        let mut rng = rand::thread_rng();
        
        let blueprints = [
            {%- for blueprint in entity_blueprints %}
            ("{{ blueprint.name }}", {{ blueprint.spawn_probability }}),
            {%- endfor %}
        ];
        
        let total_weight: f32 = blueprints.iter().map(|(_, prob)| prob).sum();
        let random_value = rng.gen::<f32>() * total_weight;
        
        let mut cumulative = 0.0;
        for (name, probability) in &blueprints {
            cumulative += probability;
            if random_value <= cumulative {
                return EntityBlueprintRegistry::spawn_by_name(world, name);
            }
        }
        
        None
    }
    
    /// Spawn multiple entities of a specific type
    pub fn spawn_batch(world: &mut World, blueprint_name: &str, count: usize) -> Vec<hecs::Entity> {
        let mut entities = Vec::with_capacity(count);
        
        for _ in 0..count {
            if let Some(entity) = EntityBlueprintRegistry::spawn_by_name(world, blueprint_name) {
                entities.push(entity);
            }
        }
        
        entities
    }
    
    /// Spawn entities for demo/testing purposes
    pub fn spawn_demo_entities(world: &mut World) -> Vec<hecs::Entity> {
        let mut entities = Vec::new();
        
        {%- for blueprint in entity_blueprints %}
        // Spawn {{ blueprint.description }}
        if {{ blueprint.name }}Blueprint::should_spawn() {
            entities.push({{ blueprint.name }}Blueprint::spawn(world));
        }
        {%- endfor %}
        
        entities
    }
} 